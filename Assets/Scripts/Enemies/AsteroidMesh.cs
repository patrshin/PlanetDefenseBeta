using UnityEngine;
using System.Collections;

public class AsteroidMesh : MonoBehaviour {

	// Mesh generation variables
	public int minSpokes = 4;
	public int maxSpokes = 12;
	public float spokeHeightMin = 1f; 
	public float spokeHeightMax = 1f;
	float averageRadius;

	Mesh mesh;
	int numSpokes;

	// Use this for initialization
	void Awake () {
		numSpokes = (int)Random.Range(minSpokes, maxSpokes);
		mesh = GetComponent<MeshFilter>().mesh;
	}
	
	

	
	/* Mesh generation */
	
	
	// Generates the asteroid's random mesh
	 public void GenerateMesh() {
		
		mesh.Clear ();
		
		Vector3 [] newVertices = generateVertices(
			numSpokes,
			spokeHeightMin,
			spokeHeightMax
			
			);
		
		
		mesh.vertices  = newVertices;
		mesh.triangles = generateTriangles(newVertices.Length-1);
		mesh.uv =        generateTexCoords();
		mesh.RecalculateNormals();
		mesh.RecalculateBounds();
		
		// If you want true collisions, consider a MeshCollider, but be aware that Unity hates flat meshes
		//GetComponent<MeshCollider>().sharedMesh = mesh;
		
		
		
		
		// Optional, set the outline child object line renderer to be the border's highlights
		setOutline();
		
	}


	public float GetAverageRadius() {
		return averageRadius;
	}
	
	
	// Generates an array of vertices that surround the centerpoint 0, 0
	// in a clockwise fashion. The points are placed uniformly around 0,0
	// at a random distance from minHeight to maxHeight. The length of the 
	// output Vertexd list is always 1 + numberOfPoints and the first element
	// is always 0, 0
	
	Vector3[] generateVertices(int numberOfDivisions, float minHeight, float maxHeight) {
		Vector3[] outVertices = new Vector3[numberOfDivisions+1];
		outVertices[0] = new Vector3(0, 0, 0);
		
		float nextRad;
		for (int i = 1; i < numberOfDivisions+1; ++i) {
			nextRad = Random.Range (minHeight, maxHeight);
			outVertices[i] = new Vector3(0, nextRad , 0);
			outVertices[i] = Quaternion.Euler(0, 0, (360.0f / (float)(numberOfDivisions))*i) * outVertices[i];
			averageRadius += nextRad;
		}
		averageRadius /= (float)numberOfDivisions;
		
		
		return outVertices;
	}
	
	
	// Generates triangles around the center based around the assumption that 
	// the vertices were generated by the generateVertices function
	int[] generateTriangles(int numVertices) {
		int[] tris = new int[numVertices*3];
		int vertexIndex = 1;
		
		for(int i = 0; i < numVertices; ++i) {
			tris[(i*3)+ 2] = 0;
			tris[(i*3)+ 1] = vertexIndex;
			tris[(i*3)+ 0] = vertexIndex+1;
			
			
			++vertexIndex;
			
		}
		
		tris[tris.Length-3] = 1;
		
		return tris;
	}
	
	
	// Generate proper texture coordinates based on vertices
	Vector2[] generateTexCoords() {
		Vector2[] outV = new Vector2[mesh.vertices.Length];
		for(int i = 0; i < mesh.vertices.Length; ++i) {
			outV[i] = new Vector2(mesh.vertices[i].x, mesh.vertices[i].y);
		}
		return outV;
		
	}
	
	
	
	
	
	
	void setOutline() {
		LineRenderer outline = GetComponentInChildren<LineRenderer>();
		if (outline) {
			outline.SetVertexCount(mesh.vertices.Length);
			outline.SetWidth(.2f, .2f);
			for(int i = 1; i < mesh.vertices.Length; ++i) {
				outline.SetPosition(i-1, new Vector3(0, 0, -.1f) + mesh.vertices[i]);
				
			}
			
			outline.SetPosition(mesh.vertices.Length-1, new Vector3(0, 0, -.1f) + mesh.vertices[1]);
		}
	}

}
